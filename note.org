- because of esrap parser is bottom up, it's not easy to validate quote-unquote levels correct, postpone validation to semantic analysis pass. In short, following should hold:
  - quote level should always ~>= 0~
  - splice must inside an array
  - if there is also quote and unquote in array, (when calculating quote level after apply splice), quote level after array must be negative. E.g.:
    - ~'(@a)~ ok, quote level after array is ~-1~
    - ~''(,@a)~ ok, quote level after array is ~-2~
    - ~'('@a)~ not ok, quote level after array is ~0~

- For a function foo, why saving both foo -> scope-defined-by-foo and mexp-of-foo -> scope-defined-by-foo in scopes?
  - For foo, you can lookup a function's scope by its qly-symbol (note qly-symbol has its location, therefore, two same named symbol will not conflict)
    - TODO: ensure hash table can actually lookup by a struct key - done, use :test 'equalp'
  - For mexp-of-foo, say you have a var defined in body of foo called bar, what scope is bar in? Textually, qly can find which mexp it is in (start, end), and find the smallest scope that contains this range (start, end). After find the scope, you can then lookup definition of bar, given any occur of bar. The reverse is not indexed and may be not needed. In IDE level it's needed as "Find Occurence" or "Find Usage". We might need to index it in compiler, if type inference require it.

Given a qly-symbol, find it's (lexical) scope
- cache: in a pass, possibly resolve-var, record every var's scope
- no cache: find smallest scope that enclosing this var

Given the qly-symbol, have its scope.
- If it's a def, you know it's type
- If it's a occur, you know it's def

Two thing consider to cache:
- symbol -> scope mapping
  - also make scopes only store mexp -> scope mapping. (Done)
  - use another hash table to keep symbol -> scope mapping
- scope -> lookup def by symbol name (already have)
- def -> occurs mapping

Do we need generic? Runtime dispatch vs Compile time dispatch
Two use cases: any generic or bind by protocol type generic.
Any generic does not limit the arg type. Assume every type can be print, A function
#+BEGIN_SRC
f[print-verbose [x]
  print["------"]
  print[x]]
#+END_SRC
without generic this x infers to type ~any~, and it's dispatched at runtime (dynamically check it's type, and print calls print-string, print-int, etc based on x's type). Purpose of generic is to make this happen at compile time, so there generate different version of print-verbose-string, print-verbose-int, etc. and if user call ~print-verbose[1]~ it will be compiled to ~print-verbose-int[1]~ thus, faster. If generic is using on many types, it increases binary size.
Bind by protocol type generic is generic but need to obey some protocol. For example a hash table, the key must obeys Hash protocol, which has a hash function to hash value of this type to a number. Again, without generic this become a runtime dispatch, with a generic it's doing compile time dispatch whenever it's possible. (It's not possible, for example, if using function to process a collection of different kind of Hash object, this case need run time dispatch anyway)
From above we can see generic is not actual a programmaing language feature but rather than an instructive for compiler to choose between "fast execution (more compile time dispatch)" and "small binary (more run time dispatch)". So as the philosophy of qly, compiler should be smart and customizable to handle these case, instead of introduce a new programming language feature of generic. To be smart, qly compiler should do compile time dispatch (auto specialize definitions when there's no or only small increase to binary size). To be customizable, user can:
- provide options to qly compiler cli, giving quantative standard of whether qly should compile something to a compile time dispatch.
- annotate on specific function to override it to do compile time or runtime dispatch.
In short, default should give a balanced performance and binary size in most use case, in special case where user need additional optimization, they still have the power to do so. To mark a function argument as compile time dispatch:
~f[foo:X:'cd]~
TO mark a function argument as runtime time dispatch:
~f[foo:X:'rd]~
