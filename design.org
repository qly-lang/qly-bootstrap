
* Syntax
#+BEGIN_SRC
mexp* := (and (? whitespace) (* mexp-whitespace))
mexp-whitespace := (and mexp (? whitespace))
whitespace := (+ (or qly-comment whitespace-char))
mexp := colon-exp-and-higher
qly-comment := (and "#" (* (not "\n")) (or "\n" eof))
whitespace-char := (or " " "\t" "\n")
eof := (! character)

colon-exp-and-higher := (or colon-exp call-dot-exp-and-higher)
call-dot-exp-and-higher := (or call-or-dot-exp primary-exp)
call-or-dot-exp := (or call-exp dot-exp)
primary-exp := (or quote-exp unquote-exp splice-exp qly-array qly-atom)

dot-exp := (and mexp-except-colon (? whitespace) "." (? whitespace) mexp-except-colon-dot-call)
colon-exp := (and mexp-except-colon (? whitespace) ":" (? whitespace) mexp-except-colon)
call-exp := (and mexp qly-array)
quote-exp := (and "'" (? whitespace) mexp)
unquote-exp := (and "," (? whitespace) mexp)
splice-exp := (and "@" (? whitespace) mexp)
qly-array := (and "[" mexp* "]")
qly-atom := (or qly-string qly-real qly-uint qly-int qly-symbol)

mexp-except-colon (or dot-exp call-exp quote-exp unquote-exp splice-exp qly-array qly-atom)
mexp-except-colon-dot-call (or quote-exp unquote-exp splice-exp qly-array qly-atom)

qly-string := (and #\" (* string-char) #\")
qly-real := (and (? (or "+" "-"))
                 (or (and (+ digit-char) "." (* digit-char)
                          (? (and (or "e" "E") (? (or "+" "-")) (+ digit-char))))
                     (and (* digit-char) "." (+ digit-char)
                          (? (and (or "e" "E") (? (or "+" "-")) (+ digit-char))))
                     (and (+ digit-char)
                          (or "e" "E") (? (or "+" "-")) (+ digit-char)))
                 (! symbol-char))
qly-uint := (and (or (and "0x" (+ hex-char))
                         (and "0o" (+ oct-char))
                         (and "0b" (+ bin-char)))
                     (! symbol-char))
qly-int := (and (? (or "+" "-")) (+ digit-char)
                    (! (or symbol-char ".")))
qly-symbol := (+ symbol-char)

string-char := (or (and #\\ character) not-doublequote)
digit-char := (digit-char-p character)
symbol-char := (or (and #\\ character) raw-symbol-char)
hex-char := (digit-char-p char 16)
oct-char := (digit-char-p char 8)
bin-char := (digit-char-p char 2)
not-doublequote := (! "\"")
raw-symbol-char := (! (or whitespace-char rule-char))
rule-char := (or "." "[" ":"" "]" "\"" "\\" "'" "," "@" "#")

#+END_SRC

* Builtin Types
*** Primitive types
**** empty type
Only nil, means nothing. Explict denote a function returns nothing is ~f[fname[args]:nil]~. nil is both a type and a symbol. The value of symbol nil is not a symbol and can be seen as nothing.
**** bool
     Only true and false and only bool type can be used in ~if~ condition. They can be expressed by true and false symbol. The value of true and false symbol is not symbol but "true" "false" value. In the other word, ~true~ is not ~'true~
**** symbol
     An interned string that can include any character. To write a symbol literal, use ~'~ before it, such as ~'i-am-a-symbol~. For whitespace, newline, tab, quote, bracket, dot, backquote, comma, backslash and sharp (which are special macro characters), they need to escape by ~\~. Symbol has no name space. A module expression ~A.B~ is a dot expression with two symbols: ~A~ and ~B~. Symbol is equal if and only if the string is same.
**** (signed) int
     - int: machine native integer type. in 32 bit machine it's int32, in 64 bit machine it's int64
     - int8, int16, int32, int64, int128, i256

     A integer literal is of type int. Unless use 3:int8 or explictly mark type when define var: v[x:int8 3]
**** uint integer
     - uint: machine native integer type. in 32 bit machine it's uint32, in 64 bit machine it's uint64
     - uint8, uint16, uint32, uint64, uint128, u256

     Use 3:uint8 as uint literal. Or use 0xf, 0b0011, 0o77, which means uint type.
**** big integer
     Bigger than i256 and u256 is expressed as big integer. Big integer is always signed and has infinite number precision (when memory allows)
**** real
     real always mean f64 in all machines. There is also f32, f64, f128 and f256 type can be used.
**** decimal
     For more precision than f256 is expressed as decimal, which has infinite precision (when memory allows)
**** other mathematical types
     Other mathematical type is supported via standard library, such as rational number, number or expression in group, ring and field.
*** Aggregate types
**** string
     string is internally UTF-8 encoded uint8 array. It support all array operations as well as string specific operation
**** atom
     All above primitive type and string is consider a single unit of the qly language and is atom type. Formally:
     #+BEGIN_SRC
t[atom or[nil bool symbol int int8 ... i256 uint uint8 ... u256 real f32 ... f256 decimal string]]
     #+END_SRC

**** array
     ~array[type]~ denote a dynamic array of type ~type~
**** struct
     ~struct[field1:type1 field2:type2 ...]~ denote an aggregate struct in contiguous memory. It has ~field1~, ~field2~, etc. of ~type1~, ~type2~, etc.
**** or type
     ~or~ type means one of type in all given candidate types.
**** named array
     named array is a meta type of ~symbol[mexp1 mexp2]~ and mostly used for meta programming.
**** mexp
     mexp is any valid qly expression.
**** low level types
     There's some additional low level types that help for more performance:
     - buffer[type n]: boundary checked fixed size array
     - enum[CAND0 CAND1 CANDN]: c-like enum that has CAND0, ... CANDN which equals to 0, ..., N respectively
     - union[CAND0 CAND1 CANDN]: c-like union that has shared memory of same type
     - emb[x]: used in struct, embed type x. By default type is reference type, embed type take that part of memory and put it inline.
* Semantics
** Define a var
   If type is not specified, it will be inferred from context.
   #+BEGIN_SRC
v[name : type val]
v[name val]
v[name : type]
   #+END_SRC

** Define a type
   Type use a different namespace than vars.
   #+BEGIN_SRC
t[name def]
   #+END_SRC

** Define a function
   Any unspecify typed args will be type inferred. Form will return a function object. If name is omitted, an anonymous function is defined. Function and var shares same namespace.
   #+BEGIN_SRC
f[fname[arg1 arg2 ...]
  mexp1
  mexp2]
f[fname[arg1:type1 ...]:rettype
  mexp1
  mexp2]
f[[arg1 arg2:type2]:rettype
  mexp1
  mexp2]
   #+END_SRC

** Block
   A block explicitly introduces a lexical scope. Top level and inside a function body introduce an implicit lexical scope. In Qly, all var in the same lexical scope is available, regardless there sequence of definition. It's not allowed to have same var defined twice in the same lexical scope
   #+BEGIN_SRC
b[mexp1
  mexp2
  ...]
   #+END_SRC

** Control Flows
*** If
    #+BEGIN_SRC
if[condition
   then-branch
   else-branch]
    #+END_SRC

*** Goto labels

*** While loop

*** For loop

*** Return from function, break and continue

** Condition System: todo, for now use only return

** Generic Function and Protocol Types
   Generic Function is function defined with same name, same length of arguments but different types. It's a general way to achieve polymorphism. Any collection of Generic Function implictly determines a Protocol Type. Implicit Protocol Type can be named to Explicit Protocol Type. Both Implicit and Explicit Protocol Type is used by Qly Compiler to do type inference, if a value is not specified a type and used as arguments as one or more generic functions. The difference between a Protocol Type to a Trait or an Interface in other programming language is Protocol Type is more general that it can polymorphic on more than one arguments. Therefore, there's no such concept as ~self~ of ~this~ in a generic function (method in other lnguages), instead, all arguments can be specialized and polymorphic to different type. For convininience purpose, qly has a ~.~ syntax sugar, which will convert a ~a.b[c]~ call to ~b[a c]~ so it looks as simple as a method call and you can always consider first argument of a generic function as `self`

   To define a protocol type, use
   #+BEGIN_SRC
t[protocol-name
  p[[type-arg1 type-arg2 ...]
    f[name1 [type-arg1 known-type1 ...]:rettype]
    f[name2 [type-arg1 type-arg2 known-type2 ...]:rettype2]]]
   #+END_SRC

   one argument can be bind by a protocol type of a partial protocol type, such as ~a:protocol-type1~ (if protocol-type1 just has one type arg that's just a. this is same as interface in other language). ~a:protocol2[a str]~ means ~a~ satisfy a protocol type that, together with str obey protocol2.

   If a and b together satisfy a protocol type X and we want to indicate that in the type annotation, we can do:
   #+BEGIN_SRC
f[fname [a:X.a b:X.b] ...]
t[protocol2
  p[arg
    f[name1 [X.a X.b arg]]]]
   #+END_SRC

   And in protocol type definition you need specify types, but in function definition it's often can be omit and type inferencer will inference the type.

* Extensions
** Parser macro
** Macro
   Macro itself is a simple concept, a macro transfer some code to other code. It's definiton looks like a function definition, takes exprs as argument and returns transformed expression. For example, suppose we have ~while~ and would like to define a infinite loop ~loop~:
   #+BEGIN_SRC
m[loop[exprs:[mexp]]
  'while[true @exprs]]
   #+END_SRC

   It took an array of mexp as argument and return tranformed expr: a ~while[true]~ with exprs inserted inside as body of ~while~. Same as call a function, if the last (here the only one) argument is an array, it can be passed as multiple arguments and qly will form it to an array. Returned expression need to be quoted, otherwise they'll be executed during computing what it'll expand to, i.e. here it must return a mexp, that is quote[mexp] evaluated to, if it were just ~while[true ...]~, This infinite loop will executed right now. It's therefore very similar to macros in lisp.

But when come to debugging, macros in other programming language can become a headache. There're two macro related debugging problems:
- macro expanding might be not as what you expected
- macro expanding is correct, but the expanded code logic is wrong (if you were not using macro but manually write expanded version of code, you'll encounter same error)

Problem 1 is addressed in lisp by ~macroexpand~ and ~macroexpand-1~, to see how macro expand looks like given specific exprs as input. You can therefore write unit test to ensure macro is expanded in an expected way. It's recommend to write this kind of test before trying to use macro to avoid problem 1, except when macro logic is trivial. Qly also has macro typed that can catch you invalid arguments. For example, you require some argument must be a dot exp.

Problem 2 is not handled properly in any existing programming language. The headache looks like this, say some programmer write code to use ~loop~ and there's a semantic error in the body of loop. In all other programming language, due to macro expand already happened. compiler will tell you something wrong in the body of ~while~. But, you'll see there's no ~while~ and realized macro defined ~loop~ isn't really a builtin operator that has same level of support like other qly builtin operator. This is both bad aesthically and practically. In practice, there's complicated macros that expands to macros that expands to macros and result code will look very different, and likely very lengthy than original macro code. Then, if somewhere there's a compile error or runtime error, what compiler / stack trace shown will become very confusing. Qly address this problem by maintain three levels of code in compiler and debug build. The lowest level is all macro is fully expanded as if there's no macro, this is same to other programming languages. The middle level expand macro one level, this helps if you want to debug your macro expanding and the code at same time. The highest and default level, is directly show error in the unexpanded form of expression, as if the macro used is just another builtin operator. For example:
#+BEGIN_SRC
f[doing-x[]]
loop[doing-x[]
     doing-y[]]
#+END_SRC
will give a compilation error:
#+BEGIN_SRC
in line 3, col 6, in ~loop~, ~doing-y~ is not defined.
#+END_SRC

This is exactly same as if loop were a builtin operator ~while~. This is even true with qly debugger, when you step, you're step expressions in ~loop~, not the orginal ~while~. Therefore you can freely extend qly with macros and all macros will look like native part of the language. If you have ensured correctness via unit tests, you don't need middle level and lowest level at all.

Let's assume ~while~ were not part of qly language, instead ~if~, ~break~ and ~loop~ were. In this case we can define ~while~ as:
#+BEGIN_SRC
m[while[condition:mexp body:[mexp]]
  '[loop [if not[,mexp]
             break[]]
         @body]]

#+END_SRC

Now if you step into while, you'll step from mexp to body of mexps, ~if~ and ~break~ is simply not visible. Also qly run full context type inference on macro definitions, it will figure out ~mexp~ evaluated to ~bool~ because it passed to argument to builtin function ~not~, therefore if you writes:
#+BEGIN_SRC
while[1
      blah[]]
#+END_SRC
Qly gives compilation error because =1 is not of type bool=.
** Generics
   There is no generic types in qly. Instead, generic is a kind of code generation that just a special case of macros. There's helper library to define generic types with macros.
** Compiler macro

* Runtime
** Memory System
*** Default: ARC, auto move and manual weak ref
    This is a balanced setup that good for most situation, only consider use GC when there's a lot of weak reference. Only consider use manual memory management when extreme high performance or low memory usages such as very limited embeded environment.

    When access to a variable, if compiler detects no further access to original variable happens, it's been moved to new var or new location. Otherwise, an automatic reference counting (ARC) happens. If in ARC case and there's a need for circular reference, use explicit weak reference to avoid circle. The syntax is ~r[source]~

    Rust style move-by-default, explicit-Arc memory management is a bad design. User often end up with a lot of Arc in a complex program. In the case of simple program where move is enough, qly compiler is smart enough to optimize an Arc to a move. In both case it's as efficient as Rust but more convinient to the programmer.
*** TODO Lazy Cyclic Reference Counting?
*** GC
*** Manual

** Raw memory and register operation

** Syscall

** FFI

* Standard Library
** Thread
** Async IO
** Data Structures
** io
** net
** math, on cpu, gpu and quantum
** x
** opengl
** browser

* Compilation
** Full context type inference
   Assume there is a function ~print[x:str]~ and another function ~print[x:int32]~, a function ~+[x:int y:int]~ and also ~append[x:str y:str]~. We have following snippet:
   #+BEGIN_SRC
f[print-fancy[x]
  print[x]
  print[aaa]
  print[append[x ccc""]]]
#+END_SRC

Inferencer knows:
#+BEGIN_SRC
x: print-protocol, where print[a:print-protocol]
x: str
#+END_SRC
two restrictions doesn't conflict, and infer to ~x:str~, and we also know ~print-fancy: f[str]:nil~

In general:
- from a function call of known type, we know types of every arguments
- from a general-function call of known type, we know types of non specialized arguments, and protocol type of specialized arguments
- If argument is an expression, we trying to further infer type of argument occur in expression
- If argument is a var, we infer this var to be of that type
- If a var is inferred with multiple type, they must be all satisfied or it's a compile time type error

If there's recursive function, thing is more difficult
#+BEGIN_SRC
f[fun1[a b]
  g[a h[b]]]

f[g[a b]
  [if =[a 1]
      fun1[a h[b]]]
      fun1[-[a 1] h[b]]]

f[h[c]
  3]
#+END_SRC

Type inference from top level:
#+BEGIN_SRC
fun1: [? ?]:?
g:[? ?]:?
h:[?]:?
#+END_SRC

Go inside fun1:
#+BEGIN_SRC
fun1: [a1 a3]:r1
g:[a1 a2]:r1
h:[a3]:a2
#+END_SRC

Go inside g:
#+BEGIN_SRC
a1: int
a3: a2
fun1: [int a2]:r1
g: [int a2]:r1
h: [a2]:a2
#+END_SRC

Go inside h:
#+BEGIN_SRC
a2: int
r1: ?
#+END_SRC

Type inference priorities:
1. orignal var type annotation, function args type annotation
2. if a function args or var missing type annotation, how is it been used.

** Apply extensions
** Coolgate IR
** x86 target
** arm target
** risc-v target
** GPGPU target
** quantum target
** Wasm target
